# -*- coding: utf-8 -*-
"""python_task_1.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1v1G05xsdZ9PFHFsilO7_TXmF3vvS5Lc5

#**Python Task 1**#

##**Question 1: Car Matrix Generation**##

Under the function named generate_car_matrix write a logic that takes the dataset-1.csv as a DataFrame. Return a new DataFrame that follows the following rules:

*   values from id_2 as columns
*   values from id_1 as index
*   dataframe should have values from car column
*   diagonal values should be 0.
"""

# Importing required libraries
import pandas as pd
import numpy as np

# Reading two CSV files into pandas DataFrames
df1 = pd.read_csv("dataset-1.csv")
df2 = pd.read_csv("dataset-2.csv")

# Defining a function to generate a car matrix from a given dataset
def generate_car_matrix(dataset_path):
    # Reading the specified CSV file into a DataFrame
    dff = pd.read_csv(dataset_path)

    # Creating a pivot table to form a matrix with 'id_1' as index, 'id_2' as columns, and 'car' as values
    car_matrix = dff.pivot(index='id_1', columns='id_2', values='car')

    # Filling NaN (missing values) with 0
    car_matrix = car_matrix.fillna(0)

    # Setting the diagonal elements to 0
    for idx in car_matrix.index:
        car_matrix.loc[idx, idx] = 0

    # Returning the resulting car matrix
    return car_matrix

# Specifying the CSV file path for the function call
csv_file_path = 'dataset-1.csv'

# Calling the function to generate the car matrix
result_matrix = generate_car_matrix(csv_file_path)

# Displaying the resulting car matrix
result_matrix

"""##**Question 2: Car Type Count Calculation**##

Create a Python function named get_type_count that takes the dataset-1.csv as a DataFrame. Add a new categorical column car_type based on values of the column car:

* low for values less than or equal to 15,
* medium for values greater than 15 and less than or equal to 25,
* high for values greater than 25.

Calculate the count of occurrences for each car_type category and return the result as a dictionary. Sort the dictionary alphabetically based on keys.
"""

def get_type_count(dataset):
    # Write your logic here

    # Defining conditions based on car values
    conditions = [
        (df1['car'] <= 15),
        (df1['car'] > 15) & (df1['car'] <= 25),
        (df1['car'] > 25)
    ]

    # Corresponding choices for each condition
    choices = ['low', 'medium', 'high']

    # Creating a new column 'car_type' based on the conditions and choices
    df1['car_type'] = np.select(conditions, choices)

    # Counting occurrences of each car_type and converting to a dictionary
    type_count = df1['car_type'].value_counts().to_dict()

    # Sorting the dictionary by keys
    type_count = {k: type_count[k] for k in sorted(type_count)}

    # Returning the resulting dictionary
    return type_count

# Specifying the dataset path for the function call
dataset_path = 'dataset-1.csv'

# Calling the function to get the type count
result_type_count = get_type_count(dataset_path)

# Displaying the resulting type count dictionary
print(result_type_count)

"""##**Question 3: Bus Count Index Retrieval**##

Create a Python function named get_bus_indexes that takes the dataset-1.csv as a DataFrame. The function should identify and return the indices as a list (sorted in ascending order) where the bus values are greater than twice the mean value of the bus column in the DataFrame.
"""

def get_bus_indexes(dataset):
    # Write your logic here

    # Calculating the mean value of the 'bus' column
    mean_bus_value = df1['bus'].mean()

    # Selecting indexes where the 'bus' value is greater than 2 times the mean value
    bus_indexes = df1[df1['bus'] > 2 * mean_bus_value].index.tolist()

    # Sorting the list of indexes
    bus_indexes.sort()

    # Returning the resulting list of indexes
    return bus_indexes

# Specifying the dataset path for the function call
dataset_path = 'dataset-1.csv'

# Calling the function to get the bus indexes
result_bus_indexes = get_bus_indexes(dataset_path)

# Displaying the resulting list of indexes
print(result_bus_indexes)

"""##**Question 4: Route Filtering**##

Create a python function filter_routes that takes the dataset-1.csv as a DataFrame. The function should return the sorted list of values of column route for which the average of values of truck column is greater than 7.
"""

def filter_routes(dataset):
    # Write your logic here

    # Calculating the average 'truck' value for each route
    route_avg_truck = df1.groupby('route')['truck'].mean()

    # Selecting routes where the average 'truck' value is greater than 7
    selected_routes = route_avg_truck[route_avg_truck > 7].index.tolist()

    # Sorting the list of selected routes
    selected_routes.sort()

    # Returning the resulting list of selected routes
    return selected_routes

# Specifying the dataset path for the function call
dataset_path = 'dataset-1.csv'

# Calling the function to filter routes
result_routes = filter_routes(dataset_path)

# Displaying the resulting list of selected routes
print(result_routes)

"""##**Question 5: Matrix Value Modification**##

Create a Python function named multiply_matrix that takes the resulting DataFrame from Question 1, as input and modifies each value according to the following logic:

* If a value in the DataFrame is greater than 20, multiply those values by 0.75,
* If a value is 20 or less, multiply those values by 1.25.

The function should return the modified DataFrame which has values rounded to 1 decimal place.
"""

def multiply_matrix(input_matrix):
    # Write your logic here

    # Creating a copy of the input matrix to avoid modifying the original
    modified_matrix = input_matrix.copy()

    # Multiplying elements greater than 20 by 0.75
    modified_matrix[modified_matrix > 20] *= 0.75

    # Multiplying elements less than or equal to 20 by 1.25
    modified_matrix[modified_matrix <= 20] *= 1.25

    # Rounding the modified matrix to one decimal place
    modified_matrix = modified_matrix.round(1)

    # Returning the modified matrix
    return modified_matrix

# Generating the input matrix using the previously defined function
result_matrix = generate_car_matrix('dataset-1.csv')

# Calling the function to modify the matrix
modified_result = multiply_matrix(result_matrix)

# Displaying the resulting modified matrix
print(modified_result)

"""##**Question 6: Time Check**##

You are given a dataset, dataset-2.csv, containing columns id, id_2, and timestamp (startDay, startTime, endDay, endTime). The goal is to verify the completeness of the time data by checking whether the timestamps for each unique (id, id_2) pair cover a full 24-hour period (from 12:00:00 AM to 11:59:59 PM) and span all 7 days of the week (from Monday to Sunday).

Create a function that accepts dataset-2.csv as a DataFrame and returns a boolean series that indicates if each (id, id_2) pair has incorrect timestamps. The boolean series must have multi-index (id, id_2).
"""

import pandas as pd

def time_check(dataset):
    # Extracting date and time columns and converting them to datetime objects
    dataset['start_datetime'] = pd.to_datetime(dataset['startDay'] + ' ' + dataset['startTime'], errors='coerce')
    dataset['end_datetime'] = pd.to_datetime(dataset['endDay'] + ' ' + dataset['endTime'], errors='coerce')

    # Applying the check_timestamps function to each group (grouped by 'id' and 'id_2')
    time_completeness = dataset.groupby(['id', 'id_2']).apply(check_timestamps).reset_index(drop=True)

    return time_completeness

def check_timestamps(group):
    # Calculating the minimum and maximum datetime values in the group
    min_datetime = group['start_datetime'].min()
    max_datetime = group['end_datetime'].max()

    # Checking if the timestamps are within the correct range
    if pd.notna(min_datetime) and pd.notna(max_datetime):
        correct_range = (min_datetime.time() == pd.Timestamp('00:00:00').time()) and \
                        (max_datetime.time() == pd.Timestamp('23:59:59').time()) and \
                        (min_datetime.day_name() == 'Monday') and \
                        (max_datetime.day_name() == 'Sunday')
    else:
        correct_range = False

    # Returning True if the timestamps are not within the correct range
    return not correct_range

# Specifying the dataset path for the function call
dataset_path = 'dataset-2.csv'

# Calling the function to check time completeness
result_completeness = time_check(pd.read_csv(dataset_path))  # Passing the dataset to the function
print(result_completeness)

