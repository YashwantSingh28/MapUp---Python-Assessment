# -*- coding: utf-8 -*-
"""python_task_2.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1pW9HfN3lwB8SQwEMl3lQcWcfZ3SutqCi

#**Python Task 2**#

##**Question 1: Distance Matrix Calculation**##

Create a function named calculate_distance_matrix that takes the dataset-3.csv as input and generates a DataFrame representing distances between IDs.

The resulting DataFrame should have cumulative distances along known routes, with diagonal values set to 0. If distances between toll locations A to B and B to C are known, then the distance from A to C should be the sum of these distances. Ensure the matrix is symmetric, accounting for bidirectional distances between toll locations (i.e. A to B is equal to B to A).
"""

import pandas as pd
import numpy as np

# Reading the CSV file into a DataFrame
df = pd.read_csv("dataset-3.csv")

# Defining a function to calculate the distance matrix
def calculate_distance_matrix(df) -> pd.DataFrame:
    # Getting unique IDs from 'id_start' and 'id_end' columns
    unique_ids = sorted(set(df['id_start'].unique()).union(df['id_end'].unique()))

    # Creating an empty DataFrame with IDs as index and columns
    distance_matrix = pd.DataFrame(index=unique_ids, columns=unique_ids)

    # Filling NaN values with 0
    distance_matrix = distance_matrix.fillna(0)

    # Populating the distance matrix based on the dataset
    for index, row in df.iterrows():
        start, end, distance = row['id_start'], row['id_end'], row['distance']
        distance_matrix.at[start, end] = distance
        distance_matrix.at[end, start] = distance

    # Updating distances in the matrix using the Floyd-Warshall algorithm
    for i in distance_matrix.index:
        for j in distance_matrix.index:
            if i == j:
                continue
            if distance_matrix.at[i, j] == 0:
                for k in distance_matrix.index:
                    if i != k and j != k and distance_matrix.at[i, k] != 0 and distance_matrix.at[k, j] != 0:
                        distance_matrix.at[i, j] = distance_matrix.at[i, k] + distance_matrix.at[k, j]

    return distance_matrix

# Calling the function to calculate the distance matrix
result_matrix = calculate_distance_matrix(df)

# Displaying the resulting distance matrix
print(result_matrix)

"""##**Question 2: Unroll Distance Matrix**##

Create a function unroll_distance_matrix that takes the DataFrame created in Question 1. The resulting DataFrame should have three columns: columns id_start, id_end, and distance.

All the combinations except for same id_start to id_end must be present in the rows with their distance values from the input DataFrame.
"""

# Defining a function to unroll the distance matrix
def unroll_distance_matrix(distance_matrix):
    # Extracting the upper triangle of the distance matrix
    upper_triangle = distance_matrix.where(np.triu(np.ones(distance_matrix.shape), k=1).astype(bool))

    # Stacking the upper triangle and resetting the index
    unrolled_df = upper_triangle.stack().reset_index()

    # Renaming the columns
    unrolled_df.columns = ['id_start', 'id_end', 'distance']

    return unrolled_df

# Calling the function to unroll the distance matrix
result_unrolled_df = unroll_distance_matrix(result_matrix)

# Displaying the resulting unrolled DataFrame
print(result_unrolled_df)

"""##**Question 3: Finding IDs within Percentage Threshold**##

Create a function find_ids_within_ten_percentage_threshold that takes the DataFrame created in Question 2 and a reference value from the id_start column as an integer.

Calculate average distance for the reference value given as an input and return a sorted list of values from id_start column which lie within 10% (including ceiling and floor) of the reference value's average.
"""

def find_ids_within_ten_percentage_threshold(df, reference_id):
    # Calculate the average distance for the reference ID
    reference_avg_distance = df[df['id_start'] == reference_id]['distance'].mean()

    # Calculate lower and upper thresholds
    lower_threshold = reference_avg_distance - (reference_avg_distance * 0.10)
    upper_threshold = reference_avg_distance + (reference_avg_distance * 0.10)

    # Filter IDs that fall within the threshold
    within_threshold_values = df[(df['distance'] >= lower_threshold) & (df['distance'] <= upper_threshold)]['id_start']

    # Sort and get unique values
    sorted_within_threshold_values = sorted(within_threshold_values.unique())

    return sorted_within_threshold_values

# Using the first ID in the result_unrolled_df DataFrame as the reference_id
reference_id = result_unrolled_df['id_start'].iloc[0]

# Calling the function to find IDs within the 10% threshold
result_list = find_ids_within_ten_percentage_threshold(result_unrolled_df, reference_id)
print(result_list)

"""##**Question 4: Calculate Toll Rate**##

Create a function calculate_toll_rate that takes the DataFrame created in Question 2 as input and calculates toll rates based on vehicle types.

The resulting DataFrame should add 5 columns to the input DataFrame: moto, car, rv, bus, and truck with their respective rate coefficients. The toll rates should be calculated by multiplying the distance with the given rate coefficients for each vehicle type:

* 0.8 for moto
* 1.2 for car
* 1.5 for rv
* 2.2 for bus
* 3.6 for truck
"""

def calculate_toll_rate(df):
    # Dictionary mapping vehicle types to rate coefficients
    rate_coefficients = {'moto': 0.8, 'car': 1.2, 'rv': 1.5, 'bus': 2.2, 'truck': 3.6}

    # Calculate toll rates for each vehicle type and add new columns to the DataFrame
    for vehicle_type, rate_coefficient in rate_coefficients.items():
        df[vehicle_type] = df['distance'] * rate_coefficient

    return df

# Calling the function to calculate toll rates
result_with_toll_rates = calculate_toll_rate(result_unrolled_df)

# Displaying the resulting DataFrame with toll rates
print(result_with_toll_rates)

"""##**Question 5: Calculate Time-Based Toll Rates**##

Create a function named calculate_time_based_toll_rates that takes the DataFrame created in Question 3 as input and calculates toll rates for different time intervals within a day.

The resulting DataFrame should have these five columns added to the input: start_day, start_time, end_day, and end_time.

* start_day, end_day must be strings with day values (from Monday to Sunday in proper case)
* start_time and end_time must be of type datetime.time() with the values from time range given below.

Modify the values of vehicle columns according to the following time ranges:

Weekdays (Monday - Friday):

* From 00:00:00 to 10:00:00: Apply a discount factor of 0.8
* From 10:00:00 to 18:00:00: Apply a discount factor of 1.2
* From 18:00:00 to 23:59:59: Apply a discount factor of 0.8

Weekends (Saturday and Sunday):

* Apply a constant discount factor of 0.7 for all times.

For each unique (id_start, id_end) pair, cover a full 24-hour period (from 12:00:00 AM to 11:59:59 PM) and span all 7 days of the week (from Monday to Sunday).
"""

from datetime import time

def calculate_time_based_toll_rates(df):
    # Define time ranges for weekdays and weekends
    time_ranges_weekdays = [(time(0, 0, 0), time(10, 0, 0)),
                            (time(10, 0, 0), time(18, 0, 0)),
                            (time(18, 0, 0), time(23, 59, 59))]

    time_ranges_weekends = [(time(0, 0, 0), time(23, 59, 59))]

    # Initialize columns for start and end day, start and end time
    df['start_day'] = df['end_day'] = df['start_time'] = df['end_time'] = None

    # Function to map time range
    def map_time_range(start, end, time_ranges):
        for time_range in time_ranges:
            if start >= time_range[0] and end <= time_range[1]:
                return time_range
        return None

    # Function to apply time-based rates
    def apply_time_based_rates(row, time_ranges, discount_factor):
        start_day = row['start_day']
        end_day = row['end_day']
        start_time = row['start_time']
        end_time = row['end_time']

        for time_range in time_ranges:
            if start_time >= time_range[0] and end_time <= time_range[1]:
                row['start_time'] = time_range[0]
                row['end_time'] = time_range[1]
                row['start_day'] = start_day
                row['end_day'] = end_day
                row[['moto', 'car', 'rv', 'bus', 'truck']] *= discount_factor
                return row

    # Iterate through rows of the DataFrame
    for index, row in df.iterrows():
        start_day = row['start_day']
        end_day = row['end_day']

        # Check if the start and end days are the same
        if start_day == end_day:
            # Apply time-based rates based on weekdays or weekends
            if start_day in ['Monday', 'Tuesday', 'Wednesday', 'Thursday', 'Friday']:
                row = apply_time_based_rates(row, time_ranges_weekdays, 0.8)
            elif start_day in ['Saturday', 'Sunday']:
                row = apply_time_based_rates(row, time_ranges_weekends, 0.7)

    return df

# Calling the function to calculate time-based toll rates
result_with_time_based_rates = calculate_time_based_toll_rates(result_with_toll_rates)

# Define the desired column order
desired_order = ['id_start', 'id_end', 'distance', 'start_day', 'start_time', 'end_day', 'end_time', 'moto', 'car', 'rv', 'bus', 'truck']

# Reordering the DataFrame based on the desired order
result_with_time_based_rates = result_with_time_based_rates[desired_order]

# Displaying the resulting DataFrame with time-based rates and desired column order
print(result_with_time_based_rates)

